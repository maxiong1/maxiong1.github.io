(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{539:function(t,n,o){"use strict";o.r(n);var s=o(35),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,o=t._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("p",[t._v("面试遇到的问题，理解this指向的小技巧")]),t._v(" "),o("p",[t._v("this 总结 ：")]),t._v(" "),o("p",[t._v("1.1 先来看看豆大神的大白话理解")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[t._v('1.1.1 找点大法：你找不到.的函数调用，this指向一般是window\n\n```\nfunction foo(){\n\tconsole.log(this)\t\n}\nfoo() // 输出window\nwindow.foo() // 输出window\n```\n\n`不用怀疑，也不用犹豫，找不到任何·的这种情况下，函数内部的this指向window`\n\n```\nfunction foo(callback){\n\tcallback() // 调用其实在这里，你是找不到·的\n}\nfoo(function(){\n\tconsole.log(this)\n})\n```\n\n`\n这个例子就是，匿名函数内部打印了this，他作为参数，内部的this指向window\n`\n\n1.1.2 找点大法：有·的函数调用，this指向一般的最后一个·左侧的那个对象：\n\n\t1.1.2.1 调用语句里面只有一个·\n\n\t```\n\tvar bar = {name:""}\n\tbar.foo = function(){console.log(this)}\n\tbar.foo() // bar \n\t这个例子我们找到了·的存在，左侧是bar，指向是bar\n\t```\n\t\n\t1.1.2.2 调用语句里能找到多个·\n\t\n\t```\n\tvar obj = {name:""}\n\tobj.bar = {name:""}\n\tobj.bar.foo = function(){\n\t\tconsole.log(this)\n\t}\n\tobj.bar.foo() // bar\n\t这个例子我们找到了两个·最后一个·左侧的对象是bar，那么this指向就是bar\n\t```\n\t㈡如果发现你找到的“.”左侧是prototype，那么再往左找一个“.”，这个“.”左侧的对象是this指向。\n\n1.1.3 面向对象中this\n\n\t```\n\tfunction foo(){\n\t\tconsole.log(this)\n\t}\n\tfoo.prototype.bar = function(){\n\t\tconsole.log(this)\n\t}\n\tfoo.prototype.func = function(fn){\n\t\tfn()\n\t}\n\tfoo() // window\n\tfoo.prototype.bar() // foo\n\tvar fo = new foo() // fo\n\tfo.bar() // fo\n\tfo.fn(function(){console.log(this)}) // window\n\t\n\t当foo() 时，foo被当作普通函数，那么遵循找点大法foo()内部的this是指向window；\n\t\n\t当foo.prototype.bar()时，foo还是被当作普通函数遵循找点大法发现有了prototype，再往左找，发现this指向foo  （谷歌里面object,在这里打印this.bar 显示为定义，所以我认为this的指向是当前函数）\n\t\n\t当new foo时，foo作为构造函数被实例化，foo内部this指向实例化后的foo，也就是我声明的fo \n\t\n\t当fo.bar时遵循找点大法发现this指向fo\n\t\n\t当fo.func(匿名函数)时，匿名函数前没有“.”，匿名函数作为参数，所以遵循㈠，发现其内部this指向window\n\n\t```\n1.1.4 call apply会改变this指向\n\n总结：\n\n•\t找不到“.”的函数调用，其内部的this一般指向window象；\n•\t找得到“.”的函数调用，其内部的this一般指向最后一个“.”左侧的那个对象，如果左侧是prototype，再向左找一个；（原理里面可能会指向当前函数，点规则无效）\n•\t明确区分函数是[构造函数]还是[普通函数]，[构造函数]内的this指向实例化后的对象；\n•\t函数作为参数传递，被调用时其内部的this一般指向window。\n•\tcall和apply会改变this指向，参阅巧妙理解call、apply。\n•\tES6/7的箭头函数也会影响this指向，这个很简单，我就不多讲啦~\n')])])]),o("p",[t._v("一句话来说，就是“谁调的我(普通函数)，我内部的this就指向谁；new我一下(构造函数)，我内部的this就指向我的实例化”")]),t._v(" "),o("h2",{attrs:{id:"我测试发现在原型内存在问题-无法访问-this指向他本身"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#我测试发现在原型内存在问题-无法访问-this指向他本身"}},[t._v("#")]),t._v(" 我测试发现在原型内存在问题，无法访问，this指向他本身")]),t._v(" "),o("p",[t._v("原型：一个属性，属性名叫prototype 只有构造函数有")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[t._v("原型链：一个属性，属性名叫做__proto__万物皆有，最后归宗到Object.prototype上，Object。prototype的__proto__ 值为null\n")])])]),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v('var a1 = function(){this.name="1"}\n\na1.prototype.bar = function(){console.log(this);console.log(this.name)}\n\na1.prototype.bar()\n\nObject bar: ()constructor: ()__proto__: Object  // this\nundefined // this,name\n')])])]),o("p",[t._v("js  实现 new 方法")]),t._v(" "),o("p",[t._v("1.创建一个空对象")]),t._v(" "),o("p",[t._v("2.利用apply改变this指向，指向foo")]),t._v(" "),o("p",[t._v("3.把foo 的__proto__属性执行 Foo 的prototype")]),t._v(" "),o("ol",{attrs:{start:"4"}},[o("li",[t._v("返回 foo")])]),t._v(" "),o("p",[t._v("（转载https://juejin.im/post/590192760ce4630061516c09）很好的一篇教程；")])])}),[],!1,null,null,null);n.default=a.exports}}]);