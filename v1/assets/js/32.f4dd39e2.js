(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{531:function(t,e,i){"use strict";i.r(e);var a=i(35),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"git-入门"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-入门"}},[t._v("#")]),t._v(" git 入门")]),t._v(" "),i("h6",{attrs:{id:"克隆现有的仓库"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#克隆现有的仓库"}},[t._v("#")]),t._v(" 克隆现有的仓库")]),t._v(" "),i("p",[t._v("克隆仓库的命令格式是 git clone [url] 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("$ git clone https://github.com/libgit2/libgit2\n")])])]),i("p",[t._v("这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("$ git clone https://github.com/libgit2/libgit2 mylibgit\n")])])]),i("p",[t._v("这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 "),i("code",[t._v("mylibgit")]),t._v("。")]),t._v(" "),i("h6",{attrs:{id:"记录每次更新到仓库"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#记录每次更新到仓库"}},[t._v("#")]),t._v(" 记录每次更新到仓库")]),t._v(" "),i("p",[i("a",{attrs:{href:"https://git-scm.com/book/en/v2/images/lifecycle.png",target:"_blank",rel:"noopener noreferrer"}},[t._v("文件的状态变化周期"),i("OutboundLink")],1)]),t._v(" "),i("ul",[i("li",[t._v("untracked 未跟踪  此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged")]),t._v(" "),i("li",[t._v("unmodified 未更改 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件")]),t._v(" "),i("li",[t._v("modified 更改 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改")]),t._v(" "),i("li",[t._v("staged 暂存状态  执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified")])]),t._v(" "),i("h6",{attrs:{id:"检查当前文件状态-可以用-git-status-命令"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#检查当前文件状态-可以用-git-status-命令"}},[t._v("#")]),t._v(" 检查当前文件状态 可以用 git status 命令")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\n\nnothing to commit, working tree clean // 这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过\n")])])]),i("h6",{attrs:{id:"状态简览-使用-git-status-s-命令或-git-status-short-命令"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#状态简览-使用-git-status-s-命令或-git-status-short-命令"}},[t._v("#")]),t._v(" 状态简览 使用 git status -s 命令或 git status --short 命令")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v(" M README  // 修改过的文件前面标记是 M 没有 add\nMM Rakefile  // 你可能注意到了 M 有两个可以出现的位置，\n\t\t\t\t出现在右边的 M 表示该文件被修改了但是还没放入暂存区，\n\t\t\t\t出现在靠左边的 M 表示该文件被修改了并放入了暂存区\nA  lib/git.rb  // 新添加到暂存区的文件前面标记是 A\nM  lib/simplegit.rb // 修改过的文件前面标记是 M 并add\n?? LICENSE.txt  // 新添加的未跟踪文件前面标记是 ??\n")])])]),i("h6",{attrs:{id:"忽略文件-gitignore"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#忽略文件-gitignore"}},[t._v("#")]),t._v(" 忽略文件 .gitignore")]),t._v(" "),i("p",[t._v(".gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交：")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("git rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n")])])]),i("p",[t._v("注意：\n不要误解了 .gitignore 文件的用途，该文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件）。\n如果文件曾经被 Git 记录过，那么.gitignore 就对它们完全无效。只能清除缓存")]),t._v(" "),i("h6",{attrs:{id:"查看已暂存和未暂存的修改"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#查看已暂存和未暂存的修改"}},[t._v("#")]),t._v(" 查看已暂存和未暂存的修改")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("* git diff 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入\n* git diff --cached 若要查看已暂存的将要添加到下次提交里的内容，可以用 \n* 或使用 git diff --staged\n")])])]),i("h6",{attrs:{id:"跳过使用暂存区域"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#跳过使用暂存区域"}},[t._v("#")]),t._v(" 跳过使用暂存区域")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('* git commit -a -m "信息" 这样就不用在 git  add 了\n')])])]),i("h6",{attrs:{id:"移动文件"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#移动文件"}},[t._v("#")]),t._v(" 移动文件")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("* 必须在版本控制之下，不忍会报错   fatal: not under version control, \n* git mv file_from file_to   \n")])])]),i("h6",{attrs:{id:"查看提交历史"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#查看提交历史"}},[t._v("#")]),t._v(" 查看提交历史")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("* git log -p 用来显示每次提交的内容差异\n* git log --stat 每次提交的简略的统计信息\n* git log --oneline 单线图\n* git log --decorate 装饰\n* git log --graph 图表\n* git log --all 全部\n")])])]),i("h6",{attrs:{id:"取消暂存的文件"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#取消暂存的文件"}},[t._v("#")]),t._v(" 取消暂存的文件")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("* git  reset\n")])])]),i("h6",{attrs:{id:"撤消对文件的修改"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#撤消对文件的修改"}},[t._v("#")]),t._v(" 撤消对文件的修改")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("* git checkout \n")])])]),i("h2",{attrs:{id:"git-分支"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-分支"}},[t._v("#")]),t._v(" git  分支")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('* git branch "xxxx"  创建分支\n* git checkout "xxx" 切换分支\n* git checkout -b "xxx" 在已有项目上创建新的分支  git branch "xxx", git checkout "xxx"\n* git branch  获取分支列表\n* git branch "xxxx" 备份分支，不会切换分支\n* git branch -v  每一个分支的最后一次提交\n* git branch --merged 哪些分支已经合并到当前分支\n* git branch -d "xxx" 删除分支\n* git push origin --delete "xxxx" 删除远程分支\n* git push origin :"分支" 删除远程分支\n* git checkout -b "xxx" origin/"xxxx" 检出远程分支到本地\n* git clone -b "xxx" "url" "本地路径" clone远程分支到本地\n')])])]),i("h6",{attrs:{id:"储藏"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#储藏"}},[t._v("#")]),t._v(" 储藏")]),t._v(" "),i("p",[t._v("通过储藏命令来存储当前修改，不提交，切换到其他分支")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("* git stash save (-u 存储任何创建的未跟踪文件。默认值存储跟踪文件)\n* git stash apply 改动重新应用\n* \n")])])]),i("h2",{attrs:{id:"问题"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("windows使用git时出现：warning: LF will be replaced by CRLF\n$ rm -rf .git  // 删除.git"),i("br"),t._v("\n$ git config --global core.autocrlf false  //禁用自动转换\n// 然后重新执行\n$ git init"),i("br"),t._v("\n$ git add .")])]),t._v(" "),i("li",[i("p",[t._v('在工程中很容易出现.gitignore并没有忽略掉我们已经添加的文件，那是因为.gitignore对已经追踪(track)的文件是无效的，需要清除缓存，清除缓存后文件将以未追踪的形式出现，这时重新添加(add)并提交(commit)就可以了。\n// 不要忘了后面的 .\ngit rm -r --cached .\ngit add .\ngit commit -m "comment')])]),t._v(" "),i("li",[i("p",[t._v("git pull 的时候 出现了")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("  `\n  \terror: You have not concluded your merge (MERGE_HEAD exists).\n  \thint: Please, commit your changes before merging.\n  \tfatal: Exiting because of unfinished merge.\n  `\n")])])])])]),t._v(" "),i("p",[t._v("本地有修改和提交，如何强制用远程的库更新更新。我尝试过用git pull -f，总是提示 You have not concluded your merge. (MERGE_HEAD exists)。")]),t._v(" "),i("p",[t._v("我需要放弃本地的修改，用远程的库的内容就可以，应该如何做？傻傻地办法就是用心的目录重新clone一个，正确的做法是什么？")]),t._v(" "),i("p",[t._v("解决")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("\t`\n\t\tgit fetch --all  获取远程所有修改\n\t\tgit reset --hard origin/master \n\t\tgit fetch 只是下载远程的库的内容，不做任何的合并git reset 把HEAD指向刚刚下载的最新的版本\n\t`\n\ngit clone -b 5005 http://git.xin.com/jinrong/fe.youxinjinrong.com.git origin/5005\n")])])]),i("h2",{attrs:{id:"git-创建分支"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-创建分支"}},[t._v("#")]),t._v(" git 创建分支")]),t._v(" "),i("p",[t._v("git push  推送\ngit pull  下拉同步")]),t._v(" "),i("ul",[i("li",[t._v("git clone https://github.com/maxiong1/xiongye.git {将xiongye从github上下载到本地}")]),t._v(" "),i("li",[t._v("进入xiongye目录")]),t._v(" "),i("li",[t._v("git branch {来查看分支}")]),t._v(" "),i("li",[t._v("git branch 分支  {来创建分支}")]),t._v(" "),i("li",[t._v("git checkout 分支 {进入此分支-切换分支}")]),t._v(" "),i("li",[t._v("上面两个合成一个 git checkout －b 分支")]),t._v(" "),i("li",[t._v("git push origin pp {将分支及分支文件推送到github仓库}")])]),t._v(" "),i("h4",{attrs:{id:"在git-pull的时候报错"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#在git-pull的时候报错"}},[t._v("#")]),t._v(" 在git pull的时候报错")]),t._v(" "),i("p",[t._v("error: Your local changes to the following files would be overwritten by merge:")]),t._v(" "),i("p",[t._v("解决办法：")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("\t\t如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:\n\t\tgit stash\n\t\tgit pull\n\t\tgit stash pop\n\t\t然后可以使用git diff -w +文件名 来确认代码自动合并的情况.\n\t\t\n\t\t如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:\n\t\tgit reset --hard\n\t\tgit pull\n\t\t其中git reset是针对版本\n")])])]),i("h5",{attrs:{id:"在git-pull的时候出出现-pull-is-not-possible-because-you-have-unmerged-files"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#在git-pull的时候出出现-pull-is-not-possible-because-you-have-unmerged-files"}},[t._v("#")]),t._v(" 在git pull的时候出出现 Pull is not possible because you have unmerged files.")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("解决：\n\n1.pull会使用git merge导致冲突，需要将冲突的文件resolve掉 git add -u, git commit之后才能成功pull.\ngit push origin master\n\n2.如果想放弃本地的文件修改，可以使用git reset --hard FETCH_HEAD，FETCH_HEAD表示上一次成功git pull之后形成的commit点。然后git pull.\n注意：\n\ngit merge会形成MERGE-HEAD(FETCH-HEAD) 。git push会形成HEAD这样的引用。HEAD代表本地最近成功push后形成的引用。\n")])])]),i("h4",{attrs:{id:"git回滚远程-实战"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git回滚远程-实战"}},[t._v("#")]),t._v(" git回滚远程－－实战")]),t._v(" "),i("ul",[i("li",[t._v("git log 查看提交历史")]),t._v(" "),i("li",[t._v("git reset –soft 一窜字符窜\n"),i("ul",[i("li",[t._v("撤销到某个版本之前，之前的修改退回到暂存区（不懂看漂亮的图哦~）。soft 和 hard参数的区别就是，hard修改记录都没了，soft则会保留修改记录。")])])]),t._v(" "),i("li",[t._v("git stash\n"),i("ul",[i("li",[t._v("暂存为了安全起见。")])])]),t._v(" "),i("li",[t._v("git push -f\n"),i("ul",[i("li",[t._v("将本地master push 到远程版本库中， -f 强制覆盖。")])])])]),t._v(" "),i("h4",{attrs:{id:"fatal-httprequestexception-encountered解决方法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#fatal-httprequestexception-encountered解决方法"}},[t._v("#")]),t._v(" fatal: HttpRequestException encountered解决方法")]),t._v(" "),i("p",[t._v("网上查了一下发现是Github 禁用了TLS v1.0 and v1.1，必须更新Windows的git凭证管理器，才行。或更新最新版本git\n"),i("a",{attrs:{href:"https://github.com/Microsoft/Git-Credential-Manager-for-Windows",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Microsoft/Git-Credential-Manager-for-Windows"),i("OutboundLink")],1)]),t._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/tag/v1.14.0",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/tag/v1.14.0"),i("OutboundLink")],1)]),t._v(" "),i("p",[t._v("重置密码")]),t._v(" "),i("p",[t._v("git config --system --unset credential.helper")]),t._v(" "),i("h2",{attrs:{id:"回滚"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#回滚"}},[t._v("#")]),t._v(" 回滚")]),t._v(" "),i("h3",{attrs:{id:"git-revert-n"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-revert-n"}},[t._v("#")]),t._v(" git revert -n")]),t._v(" "),i("ul",[i("li",[t._v("git revert -n [commit]")]),t._v(" "),i("li",[t._v("解决冲突")]),t._v(" "),i("li",[t._v("git revert --continue")]),t._v(" "),i("li",[t._v("git push")])]),t._v(" "),i("h3",{attrs:{id:"git-revert"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-revert"}},[t._v("#")]),t._v(" git revert")]),t._v(" "),i("ul",[i("li",[t._v("git revert [commit]")]),t._v(" "),i("li",[t._v("解决冲突")]),t._v(" "),i("li",[t._v("git push")])]),t._v(" "),i("h3",{attrs:{id:"pull-requests-merge-requests"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#pull-requests-merge-requests"}},[t._v("#")]),t._v(" pull requests /merge requests")]),t._v(" "),i("ul",[i("li",[t._v("本地分支开发，提交到仓库分支")]),t._v(" "),i("li",[t._v("在仓库分支创建 "),i("code",[t._v("pull requests/ merge requests")])]),t._v(" "),i("li",[t._v("审核代码，合并master")]),t._v(" "),i("li",[t._v("如果想要回滚，可进入"),i("code",[t._v("pull requests/merge resuqests")]),t._v("中点击 "),i("code",[t._v("revert")]),t._v(" 按钮即可")])]),t._v(" "),i("p",[t._v("想要撤消 "),i("code",[t._v("git revert")]),t._v(" 使用 "),i("code",[t._v("git reset --hard [commit]")])]),t._v(" "),i("p",[t._v("如果遇到 "),i("code",[t._v("Merge branch")]),t._v(" 的记录，使用"),i("code",[t._v("git revert")]),t._v(" 会出现")]),t._v(" "),i("div",{staticClass:"language-js extra-class"},[i("pre",{pre:!0,attrs:{class:"language-js"}},[i("code",[i("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("error")]),i("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" commit xxxxxx is a merge but no "),i("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("m option was given"),i("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),i("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("fatal")]),i("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" revert failed\n\n"),i("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用 git revert [commit] -m [1|2]")]),t._v("\n\n")])])]),i("h2",{attrs:{id:"合并多个commit"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#合并多个commit"}},[t._v("#")]),t._v(" 合并多个commit")]),t._v(" "),i("h2",{attrs:{id:"git-worktree"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-worktree"}},[t._v("#")]),t._v(" git worktree")]),t._v(" "),i("p",[t._v("git worktree add 本地文件 远程分支名")]),t._v(" "),i("h2",{attrs:{id:"ls-remote-h-t-git-github-com-adobe-webplatform-eve-git"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#ls-remote-h-t-git-github-com-adobe-webplatform-eve-git"}},[t._v("#")]),t._v(" ls-remote -h -t git://github.com/adobe-webplatform/eve.git")]),t._v(" "),i("p",[t._v('解决方法：\ngit config --global url."https://".insteadOf git://')]),t._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"https://www.cnblogs.com/bellkosmos/p/11409904.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/bellkosmos/p/11409904.html"),i("OutboundLink")],1)])]),t._v(" "),i("h3",{attrs:{id:"回滚案例"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#回滚案例"}},[t._v("#")]),t._v(" 回滚案例")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("开发过程中，你肯定会遇到这样的场景：\n\n* 糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！\n* 彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！\n* 刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！\n\n一、本地回滚，强推\n\ngit reset --hard commitID 回退到某个版本号 \n\n弊端:\n\t该commitID之后的提交都会删除,即，`仓库中`\n\t使用git log --pertty=oneline只能查看到之前的commit不会看到之后commit。\n\t使用git log -g (git reflog)可查看之后的commit。\n\t\n\t`\n\terror: failed to push some refs to 'https://github.com/maxiong1/test.git'\n\thint: Updates were rejected because the tip of your current branch is behind\n\thint: its remote counterpart. Integrate the remote changes (e.g.\n\thint: 'git pull ...') before pushing again.\n\thint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\t`\n\t\ngit push -u origin master -f 强推 (可能会出现无权限的问题，只要去setting->protected_branches关闭分支保护即可,===这是不行的====) \ngit reset --hard这个命令整过之后呢，就如你自己执行delete命令一样，再也尸骨难寻啦（也就是真的毛都不剩了！！默哀三秒）！！！！\n\n二、 撤销某次操作，push\n\ngit revert 撤销 某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交\n\t\ngit revert HEAD 撤销前一次commit\ngit revert HEAD^ 撤销前前一次\ngit revert commit 撤销指定commit\n\ngit revert是提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容\n\n* revert merge会出现的问题\n`\n$ git revert 6d55e80a8580d283036122d16b33205119ad1171\nerror: commit 6d55e80a8580d283036122d16b33205119ad1171 is a merge but no -m option was given.\nfatal: revert failed\n\n`\n\n这是因为你revert的那个commit是一个merge commit，它有两个parent, Git不知道base是选哪个parent，就没法diff，所以就抱怨了，所以你要显示告诉Git用哪一个parent。\n\n-m option(分类 1谁 合并了2谁)\n\n`\n$ git revert 6d55e80a8580d283036122d16b33205119ad1171 -m 2\n[master 2338121] Revert \"Merge branch 'master' into dev\"\n 3 files changed, 3 deletions(-)\n delete mode 100644 a1.txt\n delete mode 100644 a2.txt\n delete mode 100644 a3.txt\n`\n\n这样就还原了原来的master；\n如果revert错了，使用git revert  HEAD即可还原\n")])])]),i("h2",{attrs:{id:"如何恢复git删除的文件-本地"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#如何恢复git删除的文件-本地"}},[t._v("#")]),t._v(" 如何恢复git删除的文件（本地）?")]),t._v(" "),i("p",[t._v("在本地删除了文件，"),i("code",[t._v("git pull")]),t._v("是没有效果的")]),t._v(" "),i("ul",[i("li",[t._v("通过编辑器插件、git可视化工具，选择某个文件点击放弃修改，被删除的文件就会还原")]),t._v(" "),i("li",[t._v("使用 git checkout\n"),i("ul",[i("li",[t._v("git checkout 后面不加任何参数。表示核查工作区相对于版本库修改过的文件")]),t._v(" "),i("li",[t._v("git checkout  + 分支名       表示切换分支")]),t._v(" "),i("li",[t._v("git checkout  -b  分支名   表示以当前分支的当前状态创建新分支并切换到新分支    -b 表示创建新分支")]),t._v(" "),i("li",[t._v("git checkout 　[.[filename]] 当没有提交版本号时将工作区的内容恢复到暂存区的状态")]),t._v(" "),i("li",[t._v("git checkout -b 分支名  commitID   表示以当前分支的commitID提交节点创建新的分支并切换到新分支。此时工作区的内容和切换分之前commitID提交节点的内容一样")]),t._v(" "),i("li",[t._v("git checkout  commitID   此命令有些特殊，此命令执行后，工作区的内容会变成commitID提交节点的内容，但时HEAD不位于任何分支上，处于游离状态。(可对改临时分支进行操作操作完毕执行git add ，git branch -b 新分支,切换分支并merge新分支，然后再删除新分支)")]),t._v(" "),i("li",[i("a",{attrs:{href:"https://www.cnblogs.com/gaoBlog/p/10955352.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考"),i("OutboundLink")],1)])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);